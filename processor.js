(function () { "use strict"; class d { constructor(e) { this.chunks = [], this.readIndex = 0, this.readOffset = 0, this.totalLength = 0, this.TypedArrayConstructor = e } clear() { this.chunks = [], this.totalLength = 0, this.readIndex = 0, this.readOffset = 0 } enqueue(e) { e.length !== 0 && (this.chunks.push(e), this.totalLength += e.length) } dequeue(e) { if (e <= 0) throw new Error("Invalid argument: 'count' must be a positive integer"); const r = new this.TypedArrayConstructor(e); let n = 0; for (; n < e && !(this.readIndex >= this.chunks.length);) { const s = this.chunks[this.readIndex], a = s.length - this.readOffset, l = Math.min(a, e - n); r.set(s.subarray(this.readOffset, this.readOffset + l), n), this.readOffset += l, n += l, this.readOffset >= s.length && (this.readIndex += 1, this.readOffset = 0) } return this.totalLength -= n, this.readIndex > 0 && (this.chunks.splice(0, this.readIndex), this.readIndex = 0), r } get length() { return this.totalLength } } function c(t, e, r) { for (let n = 0; n < r.length; n++)t.setUint8(e + n, r.charCodeAt(n)) } function m(t) { const h = t.length * 2, p = 44 + h, w = new ArrayBuffer(p), o = new DataView(w), A = new Uint8Array(w); c(o, 0, "RIFF"), o.setUint32(4, p - 8, !0), c(o, 8, "WAVE"), c(o, 12, "fmt "), o.setUint32(16, 16, !0), o.setUint16(20, 1, !0), o.setUint16(22, 1, !0), o.setUint32(24, 24e3, !0), o.setUint32(28, 48e3, !0), o.setUint16(32, 2, !0), o.setUint16(34, 16, !0), c(o, 36, "data"), o.setUint32(40, h, !0); const S = new Uint8Array(t.buffer); return A.set(S, 44), A } function y(t) { const e = t.replace(/[^A-Za-z0-9+/_-]/g, "").replace(/-/g, "+").replace(/_/g, "/"), r = atob(e), n = r.length, s = new Uint8Array(n); for (let a = 0; a < n; a++)s[a] = r.charCodeAt(a); return s } const U = 8192; let i = null, u = null; const I = { init: t => (t.outputs.chunks && (i = new d(Int16Array)), t.outputs.wav && (u = new d(Int16Array)), { data: null }), add: t => { typeof t == "string" && (t = g(t)); const e = C(t); if (u == null || u.enqueue(e), i == null || i.enqueue(e), i && i.length >= U) { const r = i.dequeue(i.length); f(r.buffer).then(n => { b({ type: "chunk", data: n }) }) } return { data: null } }, clear: () => (i == null || i.clear(), u == null || u.clear(), { data: null }), getWav: async () => { if (!u) throw new Error("WAV output not enabled"); const t = u.dequeue(u.length); return { data: await f(m(t).buffer) } }, toBase64: async t => ({ data: await f(t) }), base64ToFloat32Array: t => { const e = g(t); return { data: e, transfer: [e.buffer] } }, base64ToBytes: t => { const e = y(t); return { data: e, transfer: [e.buffer] } } }; function C(t) { const e = new Int16Array(t.length); for (let r = 0; r < t.length; r++) { const n = Math.max(-1, Math.min(1, t[r])); e[r] = n < 0 ? n * 32768 : n * 32767 } return e } function f(t) { const e = new Uint8Array(t); return new Promise((r, n) => { const s = new Blob([e.buffer], { type: "application/octet-stream" }), a = new FileReader; a.onload = () => { const h = a.result.split(",")[1]; r(h) }, a.onerror = n, a.readAsDataURL(s) }) } function g(t) { const e = y(t), r = new Int16Array(e.buffer), n = new Float32Array(r.length); for (let s = 0; s < r.length; s++)n[s] = r[s] / 32768; return n } const b = (t, e) => { self.postMessage(t, e) }; self.onmessage = async t => { var e; if (((e = t.data) == null ? void 0 : e.type) === "request") { const { payload: r, nonce: n } = t.data, { data: s, transfer: a } = await I[r.type](r.data); b({ type: "response", data: s, nonce: n }, { transfer: a }); return } } })();